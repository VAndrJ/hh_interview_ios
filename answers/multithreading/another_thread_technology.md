## Какие технологии в iOS возможно использовать для работы с потоками. Преимущества и недостатки.

[**Вернутся к списку вопросов**](https://github.com/Torlopov-Andrey/hh_interview_ios/blob/master/readme.md)


### NSObject
В iOS и OSx 10.5+ объекты могут порождать потоки и использовать их для вызова одного из их методов
```objective-c
performSelectorInBackground:withObject: метод создает новый отдельный поток.
   [myObj performSelectorInBackground:@selector(doSomething) withObject:nil];
```
Эффект такой же если бы мы вызвыали метод NSThread с текущим объектом, селектором и параметреами объекта. Новый поток порождает   немедленное использование дефолтной конфигурации и начинает выполняться.

* (-) Не позволяет ограничивать потоки.
* (+) Простота создания

### POSIX Thread.
Про них только слышал. Работать не приходилось.
Отличие POSIX Thread от NSThread - в том что в первом случае это библиотека Си, во втором - библиотеки obj-c.

##### Ссылки
* [StackOverFlow](http://stackoverflow.com/questions/4358976/nsthread-vs-pthreads)
* [Apple documentation (thread, posix thread etc...)](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html)


### NSThread
Обычный класс obj-c.
[Документация apple: ](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSThread_Class/)

* (+): Покторное использование кода, требует передачи селектора и объекта, позволяет настраивать некоторые параметры (приоритет и размер стека)
* (-) сложно управлять потоками.

### GCD

Grand Central Dispatch
Обертка над `NSThread`. Делает работу с потоками более удобной.

##### Ссылки
* [Туториал по GCD на swift. Часть 1](http://swiftbook.ru/content/tutorials/grand-central-dispatch-part1)
* [Туториал по GCD на swift. Часть 2](http://swiftbook.ru/content/tutorials/grand-central-dispatch-part2)

В `GCD` можно (и нужно) использовать под разные нужны различные типы очередей.

#### Типы очередей в GCD

Во-первых, система представляет вам специальную последовательную очередь - основную очередь (main queue). Как и в любой последовательной очереди, задачи в этой очереди выполняются по одной. Тем не менее, это гарантирует, что все задачи будут выполняться на главном потоке, который является единственным потоком, которому разрешено обновить ваш пользовательский интерфейс. Только эта очередь используется для отправки сообщений на объекты UIView или для размещения уведомлений.

Система также предоставляет вам несколько согласованных очередей. Эти очереди связаны с их собственным классом QoS (Quality of Service). Классы QoS предназначены, чтобы выразить намерения представленной задачи, так чтобы GCD смог определить, как лучше расставить приоритеты:

* `QOS_CLASS_USER_INTERACTIVE`: Интерактивный пользовательский класс (user interactive) представляет задачи, которые необходимо сделать немедленно. Используйте его для обновления пользовательского интерфейса, обработки событий или небольших работ, которые должны быть выполнены с небольшими задержками. Общий объем работ, сделанный в этом классе во время выполнения вашего приложения, должен быть небольшим.
* `QOS_CLASS_USER_INITIATED`: Инициированный пользовательский класс представляет задачи, которые инициируются из пользовательского интерфейса и могут быть выполнены асинхронно. Его нужно использовать, когда пользователь ждет немедленных результатов, и для задач, требующих продолжения взаимодействия с пользователем.
* `QOS_CLASS_UTILITY`: Класс Утилит (utility) представляет длительные  по исполнению задачи, как правило, с видимым для пользователя индикатором загрузки. Используйте его для вычислений, I/O, при работе с сетями, непрерывных каналов передачи данных и подобных друг другу задач. Этот класс является энергоэффективным, к тому же имеет низкое энергопотребление.
* `QOS_CLASS_BACKGROUND`: Класс background представляет задачи, о которых пользователь может не знать напрямую. Используйте его для предварительной выборки, технического обслуживания и других задач, которые не требуют взаимодействия с пользователем и не требовательны ко времени исполнения.
Помните, что Apple API-интерфейсы также использует глобальные очереди отправки, так что задачи, которые вы добавляете, не будут единственными в этих очередях.

Наконец, вы можете создать свою собственную последовательную или согласованную очередь. Это означает, что у вас есть по крайней мере пять очередей в вашем распоряжении: главная очередь, четыре глобальные очереди отправки, плюс любые пользовательские очереди, которые вы добавляете сами!

Вот такая картина вырисовывается об "очередях отправки"!

"Искусство" в GCD сводится к выбору правильной функции очереди отправки для добавления работы в очередь. Лучший способ научиться - это поэксперементировать в приведенных ниже примерах, где мы представили некоторые общие рекомендации.


### NSOperationQueue
Это обертка над GCD. Apple рекомендует использовать эту технологию по работе с потоками.

(+)Автоматически создает и управляет потоками, позволяет ограничивать одновременно выполняющиеся потоки
(-)Более сложный механизм. Необходим для управления потоками.

### NSOperation
(+)Позволяет переопределять любые аспекты реализации. Может выполнять такие важные действия, как завершение , приостановка и возобновление потока.
(-)Необходим новый класс. Более сложный механизм, поэтому велика вероятность ошибок.


### NSInvocationOperation
(+)Автоматически создает и у правляет потоками. Метод может меняться в зависимости от ввода пользователя за счет создания нового объекта операции вызова.
(-)Трудно специализировать поведение каждого потока.
