## Опишите `основные понятия ОО парадигмы` в терминах Objective-C (`интерфейс, реализация, свойства, протоколы,` иa т.д)

[**Вернутся к списку вопросов**](https://github.com/Torlopov-Andrey/hh_interview_ios/blob/master/readme.md)

## Основные понятия ООП:
### Абстракция

**Коротко:**  Реализации в Objective-C нет.

**Подробней:**  `Абстрагирование` - это способ выделить существенные свойства и игнориро- вать несущественные. Соответственно, абстракция - это набор выделенных су- щественных свойств.
Существенные свойства - это свойства, которыми сущность обязана обладать, чтобы быть именно этой сущностью. Несущественные свойства - свойства, обла- дание которыми необязательно.
С точки зрения сложности, главное достоинство абстракции в том, что она позволяет игнорировать несущественные детали (не имеющие значения для про- граммы). Абстракция - это один из главных способов борьбы со сложностью ре- ального мира.

### Класс

`Класс` - это абстрактная (виртуальная) модель (абстрактный тип данных), еще несуществующей сущности. Фактически класс является образцом для создания новых объектов или сущностей (формулой или руководством по эксплуатации). Обычно классы относятся к статичным сущностям, существующим в коде и неиз- менным в процессе выполнения.
В отличии от объектов, классы обычно не содержат данных. Передача данных классу позволяет создавать объекты, описанного в классе типа (в ООП понятия тип данных и класс - синонимы).
Объект, созданный по образцу класса называют экземпляром этого класса. Основное предназначение классов - определять поведение своих экземпляров. Обычно классы создают таким образом, чтобы они описывали объекты предмет- ной области (объекты реального мира).
Классы позволяют описывать одинаковые сущности только один раз, умень- шая этим размеры и сложность программы.


Пример простого класса:

```Objective-C
//Файл с заголовками (интерфейсная часть)
#import <Foundation/Foundation.h>
@interface LovecraftsDeity : NSObject

@end
```

```Objective-C
//Файл с имплементацией
#import "LovecraftsDeity.h"
@implementation LovecraftsDeity

@end
```

### Объект

В основе ООП находится понятие объекта. `Объект` - это абстракция изменяемого состояния памяти компьютера. Обычно объекты относятся к динамичным сущностям, создаваемым и изменяемым в процессе выполнения программы. Объекты обладают состоянием и поведением.
Состояние объекта зависит от значения его свойств (хранимых объектом данных). Поведение объекта зависит от набора доступных ему методов. `Методы` - это сообщения, которыми обмениваются объекты. Это абстрактные сущности, определяющие действия, которые можно выполнить над объектом и действия, которые сам объект может выполнять. Пользуясь методами объекта мы можем влиять на его состояние, а посылая сообщения классу мы можем изменять состояние всех его экземпляров.

Таким образом ООП оперирует состоянием, заключенным внутри объекта, и позволяет влиять на него с помощью предоставленных методов.
Создание объектов позволяет уменьшить сложность программы, акцентируя внимание только на использующихся сущностях и их взаимодействии.

Пример объекта на основе ранее описанного класса:

```Objective-C
LovecraftsDeity *cthulhu = [LovecraftsDeity new];
```

### Свойство

...

### Метод

...


### Инкапсуляция

`Инкапсуляция` - это механизм языка, позволяющий сущности объединять в себе данные и методы для работы с этими данными. Данные при этом скрыты от остальной программы, а методы доступны для взаимодействия объектов. Объект не считается отдельной сущностью, если его состояние может быть изменено без явного использования ссылки на объект.
* Инкапсуляция позволяет распараллелить процессы создания программы, ускоряя разработку ПО
* Инкапсуляция снижает сложность разработки, позволяя сосредоточиться
на небольших фрагментах программы
* Инкапсуляция помогает сокрытию деталей реализации, необходимых про- грамме, но выходящих за рамки абстракции. Инкапсуляция помогает управлять сложностью, скрывая доступ к ней.

```Objective-C
//Файл с заголовками (интерфейсная часть)
#import <Foundation/Foundation.h>
@interface LovecraftsDeity : NSObject
-(void)call;
@end
```

```Objective-C
//Файл с имплементацией
#import "LovecraftsDeity.h"
@implementation LovecraftsDeity
-(void)call {
    NSLog(@"The Call of LovecraftsDeity");
    NSLog(@"Some complicated methods...");
}
@end
```


### Наследование
`Наследование` - это механизм языка, позволяющий сущности использовать структуру другой сущности, заимствуя и расширяя уже имеющуюся функциональность (например классы расширяют возможности модулей). Класс, который заимствуется (наследуется) называется базовым или суперклассом, а класс, который заимствует (наследует) - производным или подклассом. Все базовые и производные классы в общем создают иерархию классов программы.
* Наследованиеснижаетвремянаразработкузасчетповторногоиспользования кода;
* Наследование снижает сложность, позволяя использовать уже известные фрагменты программы. Однако при сложной иерархии повышается объем кода, с которым работает программист в отдельный момент времени;
* Наследование дополняет абстракцию,выделяя сущности с незначительным уровнем различий. Наследование позволяет создавать абстракции с различным уровнем реализации (дополнительными группами существенных свойств).

Наследник класса №1:
```Objective-C
#import "LovecraftsDeity.h"
@interface Cthulhu : LovecraftsDeity
@property (nonatomic, strong) NSNumber *tentacles;
@end
```

```Objective-C
#import "Cthulhu.h"
@implementation Cthulhu
@end
```

Наследник класса №2:
```Objective-C
#import "LovecraftsDeity.h"
@interface Shub_Niggurath : LovecraftsDeity
-(void)generateMonsters;
@end
```

```Objective-C
#import "Shub-Niggurath.h"
@implementation Shub_Niggurath
-(void)generateMonsters {
  NSLog(@"Generate legion of monsters...");
}
@end
```

### Полиморфизм

...
